<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Projeto AED: LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Projeto AED
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_linked_ref_map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Container class representing a vector of objects with keys.  
 <a href="class_linked_ref_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9db9596845180652ad8b36774d6d9b30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> = T *</td></tr>
<tr class="separator:a9db9596845180652ad8b36774d6d9b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57b9ddb3cac6283df8b9747dff2e1da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ae57b9ddb3cac6283df8b9747dff2e1da">Vec</a> = <a class="el" href="liblodepng_2lodepng_8cpp.html#ac8c5476186a019b60cc8fd4cc6ea41a1">std::vector</a>&lt; <a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &gt;</td></tr>
<tr class="separator:ae57b9ddb3cac6283df8b9747dff2e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c1420984bc5d41ef945689343be5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> = typename Vec::iterator</td></tr>
<tr class="separator:aee7c1420984bc5d41ef945689343be5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d600d6dc898d3efd063381f60eaaf7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> = typename Vec::const_iterator</td></tr>
<tr class="separator:ae9d600d6dc898d3efd063381f60eaaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63027ad3bccd9ba3a87b2818ecf12a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> = typename Vec::reverse_iterator</td></tr>
<tr class="separator:a7c63027ad3bccd9ba3a87b2818ecf12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d04d68baaeb769cfe0e3cfa9873e40f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> = typename Vec::const_reverse_iterator</td></tr>
<tr class="separator:a5d04d68baaeb769cfe0e3cfa9873e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db9596845180652ad8b36774d6d9b30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> = T *</td></tr>
<tr class="separator:a9db9596845180652ad8b36774d6d9b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57b9ddb3cac6283df8b9747dff2e1da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ae57b9ddb3cac6283df8b9747dff2e1da">Vec</a> = <a class="el" href="liblodepng_2lodepng_8cpp.html#ac8c5476186a019b60cc8fd4cc6ea41a1">std::vector</a>&lt; <a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &gt;</td></tr>
<tr class="separator:ae57b9ddb3cac6283df8b9747dff2e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c1420984bc5d41ef945689343be5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> = typename Vec::iterator</td></tr>
<tr class="separator:aee7c1420984bc5d41ef945689343be5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d600d6dc898d3efd063381f60eaaf7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> = typename Vec::const_iterator</td></tr>
<tr class="separator:ae9d600d6dc898d3efd063381f60eaaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63027ad3bccd9ba3a87b2818ecf12a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> = typename Vec::reverse_iterator</td></tr>
<tr class="separator:a7c63027ad3bccd9ba3a87b2818ecf12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d04d68baaeb769cfe0e3cfa9873e40f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> = typename Vec::const_reverse_iterator</td></tr>
<tr class="separator:a5d04d68baaeb769cfe0e3cfa9873e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f6506fe8d15e7f43f61929560a3c377"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a> (const <a class="el" href="libmscgen_2gd_8h.html#a13690c1a2aacb1c8261e3be3c4a4f4b2">std::string</a> &amp;key) const</td></tr>
<tr class="separator:a9f6506fe8d15e7f43f61929560a3c377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3f8cefe5cfd6d46e95889817b92140"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a3d3f8cefe5cfd6d46e95889817b92140">find</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;key) const</td></tr>
<tr class="separator:a3d3f8cefe5cfd6d46e95889817b92140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed765c5f6f6956643f0753c9ea1d714e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#aed765c5f6f6956643f0753c9ea1d714e">find</a> (const char *key) const</td></tr>
<tr class="separator:aed765c5f6f6956643f0753c9ea1d714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e393b31c768a9de5d04455a8596e1a9"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a0e393b31c768a9de5d04455a8596e1a9">find</a> (const char *key)</td></tr>
<tr class="memdesc:a0e393b31c768a9de5d04455a8596e1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const wrapper for find() const  <a href="class_linked_ref_map.html#a0e393b31c768a9de5d04455a8596e1a9">More...</a><br /></td></tr>
<tr class="separator:a0e393b31c768a9de5d04455a8596e1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f413af4720b2f575c911b78ee3a70b1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a2f413af4720b2f575c911b78ee3a70b1">find</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;key)</td></tr>
<tr class="separator:a2f413af4720b2f575c911b78ee3a70b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab86c77d6037d5fc0be82fca6e1587"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a6dab86c77d6037d5fc0be82fca6e1587">find</a> (const <a class="el" href="libmscgen_2gd_8h.html#a13690c1a2aacb1c8261e3be3c4a4f4b2">std::string</a> &amp;key)</td></tr>
<tr class="memdesc:a6dab86c77d6037d5fc0be82fca6e1587"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const wrapper for find() const  <a href="class_linked_ref_map.html#a6dab86c77d6037d5fc0be82fca6e1587">More...</a><br /></td></tr>
<tr class="separator:a6dab86c77d6037d5fc0be82fca6e1587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273fe87b60116a378346a858e11e4b6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a273fe87b60116a378346a858e11e4b6e">add</a> (const char *k, T *obj)</td></tr>
<tr class="separator:a273fe87b60116a378346a858e11e4b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf21f8a88dc994cf1de14246e679579"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#acaf21f8a88dc994cf1de14246e679579">add</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;k, T *obj)</td></tr>
<tr class="separator:acaf21f8a88dc994cf1de14246e679579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821db7bc14f1498938bd5314502f3655"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a821db7bc14f1498938bd5314502f3655">prepend</a> (const char *k, T *obj)</td></tr>
<tr class="separator:a821db7bc14f1498938bd5314502f3655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b0589fd4091da2efa1c5ee2da43f73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a98b0589fd4091da2efa1c5ee2da43f73">prepend</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;key, T *obj)</td></tr>
<tr class="separator:a98b0589fd4091da2efa1c5ee2da43f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad70772de2ff561c5883f5a8919c5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a5fad70772de2ff561c5883f5a8919c5d">del</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;key)</td></tr>
<tr class="separator:a5fad70772de2ff561c5883f5a8919c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89581f93afd0740dee45e136d1a54546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a89581f93afd0740dee45e136d1a54546">operator[]</a> (size_t pos)</td></tr>
<tr class="separator:a89581f93afd0740dee45e136d1a54546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d227163284233b8e37f3a265510b49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a09d227163284233b8e37f3a265510b49">operator[]</a> (size_t pos) const</td></tr>
<tr class="separator:a09d227163284233b8e37f3a265510b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f30ce85fd85bfb75bcb56bd10fe9a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ac2f30ce85fd85bfb75bcb56bd10fe9a4">begin</a> ()</td></tr>
<tr class="separator:ac2f30ce85fd85bfb75bcb56bd10fe9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d843d470df85d608d8d47b2a56c5e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a7d843d470df85d608d8d47b2a56c5e80">end</a> ()</td></tr>
<tr class="separator:a7d843d470df85d608d8d47b2a56c5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3307eb17ea829836140639cb52115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a77a3307eb17ea829836140639cb52115">begin</a> () const</td></tr>
<tr class="separator:a77a3307eb17ea829836140639cb52115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed959ab40da898bbebfdb3c8653b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a6fed959ab40da898bbebfdb3c8653b2c">end</a> () const</td></tr>
<tr class="separator:a6fed959ab40da898bbebfdb3c8653b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac971d2e3cc8e2651f5648b6946b25bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ac971d2e3cc8e2651f5648b6946b25bd7">rbegin</a> ()</td></tr>
<tr class="separator:ac971d2e3cc8e2651f5648b6946b25bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a306a67c71e29179b309647309d6e96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a2a306a67c71e29179b309647309d6e96">rend</a> ()</td></tr>
<tr class="separator:a2a306a67c71e29179b309647309d6e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d088d23b0ce73cf2ed3b8cfc2fbe89d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a2d088d23b0ce73cf2ed3b8cfc2fbe89d">rbegin</a> () const</td></tr>
<tr class="separator:a2d088d23b0ce73cf2ed3b8cfc2fbe89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67fb1418120d42cf91a2a033a6b16ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ab67fb1418120d42cf91a2a033a6b16ad">rend</a> () const</td></tr>
<tr class="separator:ab67fb1418120d42cf91a2a033a6b16ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eea714e29d412612981ac2a8bcab40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ad4eea714e29d412612981ac2a8bcab40">empty</a> () const</td></tr>
<tr class="separator:ad4eea714e29d412612981ac2a8bcab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe0b41a59bcf683e2ade44911a3fe1d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a5fe0b41a59bcf683e2ade44911a3fe1d">size</a> () const</td></tr>
<tr class="separator:a5fe0b41a59bcf683e2ade44911a3fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67fa2110f306614b020782b88c28c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ad67fa2110f306614b020782b88c28c83">clear</a> ()</td></tr>
<tr class="separator:ad67fa2110f306614b020782b88c28c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6506fe8d15e7f43f61929560a3c377"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a> (const <a class="el" href="libmscgen_2gd_8h.html#a13690c1a2aacb1c8261e3be3c4a4f4b2">std::string</a> &amp;key) const</td></tr>
<tr class="separator:a9f6506fe8d15e7f43f61929560a3c377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3f8cefe5cfd6d46e95889817b92140"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a3d3f8cefe5cfd6d46e95889817b92140">find</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;key) const</td></tr>
<tr class="separator:a3d3f8cefe5cfd6d46e95889817b92140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed765c5f6f6956643f0753c9ea1d714e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#aed765c5f6f6956643f0753c9ea1d714e">find</a> (const char *key) const</td></tr>
<tr class="separator:aed765c5f6f6956643f0753c9ea1d714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e393b31c768a9de5d04455a8596e1a9"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a0e393b31c768a9de5d04455a8596e1a9">find</a> (const char *key)</td></tr>
<tr class="memdesc:a0e393b31c768a9de5d04455a8596e1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const wrapper for find() const  <a href="class_linked_ref_map.html#a0e393b31c768a9de5d04455a8596e1a9">More...</a><br /></td></tr>
<tr class="separator:a0e393b31c768a9de5d04455a8596e1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f413af4720b2f575c911b78ee3a70b1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a2f413af4720b2f575c911b78ee3a70b1">find</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;key)</td></tr>
<tr class="separator:a2f413af4720b2f575c911b78ee3a70b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab86c77d6037d5fc0be82fca6e1587"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a6dab86c77d6037d5fc0be82fca6e1587">find</a> (const <a class="el" href="libmscgen_2gd_8h.html#a13690c1a2aacb1c8261e3be3c4a4f4b2">std::string</a> &amp;key)</td></tr>
<tr class="memdesc:a6dab86c77d6037d5fc0be82fca6e1587"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-const wrapper for find() const  <a href="class_linked_ref_map.html#a6dab86c77d6037d5fc0be82fca6e1587">More...</a><br /></td></tr>
<tr class="separator:a6dab86c77d6037d5fc0be82fca6e1587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273fe87b60116a378346a858e11e4b6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a273fe87b60116a378346a858e11e4b6e">add</a> (const char *k, T *obj)</td></tr>
<tr class="separator:a273fe87b60116a378346a858e11e4b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf21f8a88dc994cf1de14246e679579"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#acaf21f8a88dc994cf1de14246e679579">add</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;k, T *obj)</td></tr>
<tr class="separator:acaf21f8a88dc994cf1de14246e679579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821db7bc14f1498938bd5314502f3655"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a821db7bc14f1498938bd5314502f3655">prepend</a> (const char *k, T *obj)</td></tr>
<tr class="separator:a821db7bc14f1498938bd5314502f3655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b0589fd4091da2efa1c5ee2da43f73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a98b0589fd4091da2efa1c5ee2da43f73">prepend</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;key, T *obj)</td></tr>
<tr class="separator:a98b0589fd4091da2efa1c5ee2da43f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad70772de2ff561c5883f5a8919c5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a5fad70772de2ff561c5883f5a8919c5d">del</a> (const <a class="el" href="class_q_c_string.html">QCString</a> &amp;key)</td></tr>
<tr class="separator:a5fad70772de2ff561c5883f5a8919c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89581f93afd0740dee45e136d1a54546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a89581f93afd0740dee45e136d1a54546">operator[]</a> (size_t pos)</td></tr>
<tr class="separator:a89581f93afd0740dee45e136d1a54546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d227163284233b8e37f3a265510b49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a09d227163284233b8e37f3a265510b49">operator[]</a> (size_t pos) const</td></tr>
<tr class="separator:a09d227163284233b8e37f3a265510b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f30ce85fd85bfb75bcb56bd10fe9a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ac2f30ce85fd85bfb75bcb56bd10fe9a4">begin</a> ()</td></tr>
<tr class="separator:ac2f30ce85fd85bfb75bcb56bd10fe9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d843d470df85d608d8d47b2a56c5e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a7d843d470df85d608d8d47b2a56c5e80">end</a> ()</td></tr>
<tr class="separator:a7d843d470df85d608d8d47b2a56c5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3307eb17ea829836140639cb52115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a77a3307eb17ea829836140639cb52115">begin</a> () const</td></tr>
<tr class="separator:a77a3307eb17ea829836140639cb52115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed959ab40da898bbebfdb3c8653b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a6fed959ab40da898bbebfdb3c8653b2c">end</a> () const</td></tr>
<tr class="separator:a6fed959ab40da898bbebfdb3c8653b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac971d2e3cc8e2651f5648b6946b25bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ac971d2e3cc8e2651f5648b6946b25bd7">rbegin</a> ()</td></tr>
<tr class="separator:ac971d2e3cc8e2651f5648b6946b25bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a306a67c71e29179b309647309d6e96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a2a306a67c71e29179b309647309d6e96">rend</a> ()</td></tr>
<tr class="separator:a2a306a67c71e29179b309647309d6e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d088d23b0ce73cf2ed3b8cfc2fbe89d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a2d088d23b0ce73cf2ed3b8cfc2fbe89d">rbegin</a> () const</td></tr>
<tr class="separator:a2d088d23b0ce73cf2ed3b8cfc2fbe89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67fb1418120d42cf91a2a033a6b16ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ab67fb1418120d42cf91a2a033a6b16ad">rend</a> () const</td></tr>
<tr class="separator:ab67fb1418120d42cf91a2a033a6b16ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eea714e29d412612981ac2a8bcab40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ad4eea714e29d412612981ac2a8bcab40">empty</a> () const</td></tr>
<tr class="separator:ad4eea714e29d412612981ac2a8bcab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe0b41a59bcf683e2ade44911a3fe1d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a5fe0b41a59bcf683e2ade44911a3fe1d">size</a> () const</td></tr>
<tr class="separator:a5fe0b41a59bcf683e2ade44911a3fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67fa2110f306614b020782b88c28c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#ad67fa2110f306614b020782b88c28c83">clear</a> ()</td></tr>
<tr class="separator:ad67fa2110f306614b020782b88c28c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa825d33ecc2a6b96492886f163b7d47a"><td class="memItemLeft" align="right" valign="top">Map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a></td></tr>
<tr class="separator:aa825d33ecc2a6b96492886f163b7d47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad918f78e81ed4580bcd9c0654fced1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_linked_ref_map.html#ae57b9ddb3cac6283df8b9747dff2e1da">Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a></td></tr>
<tr class="separator:a1ad918f78e81ed4580bcd9c0654fced1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, class Hash = std::hash&lt;std::string&gt;, class KeyEqual = std::equal_to&lt;std::string&gt;, class Map = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt;<br />
class LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;</div><p >Container class representing a vector of objects with keys. </p>
<p >Objects can be efficiently be looked up given the key. Objects are <em>not</em> owned by the container, the container will only hold references. When adding objects the order of addition is kept, and used while iterating. </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00231">231</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae9d600d6dc898d3efd063381f60eaaf7" name="ae9d600d6dc898d3efd063381f60eaaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d600d6dc898d3efd063381f60eaaf7">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::const_iterator =  typename Vec::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00237">237</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="ae9d600d6dc898d3efd063381f60eaaf7" name="ae9d600d6dc898d3efd063381f60eaaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d600d6dc898d3efd063381f60eaaf7">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::const_iterator =  typename Vec::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00237">237</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="a5d04d68baaeb769cfe0e3cfa9873e40f" name="a5d04d68baaeb769cfe0e3cfa9873e40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d04d68baaeb769cfe0e3cfa9873e40f">&#9670;&nbsp;</a></span>const_reverse_iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::const_reverse_iterator =  typename Vec::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00239">239</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="a5d04d68baaeb769cfe0e3cfa9873e40f" name="a5d04d68baaeb769cfe0e3cfa9873e40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d04d68baaeb769cfe0e3cfa9873e40f">&#9670;&nbsp;</a></span>const_reverse_iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::const_reverse_iterator =  typename Vec::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00239">239</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="aee7c1420984bc5d41ef945689343be5c" name="aee7c1420984bc5d41ef945689343be5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7c1420984bc5d41ef945689343be5c">&#9670;&nbsp;</a></span>iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::iterator =  typename Vec::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00236">236</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="aee7c1420984bc5d41ef945689343be5c" name="aee7c1420984bc5d41ef945689343be5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7c1420984bc5d41ef945689343be5c">&#9670;&nbsp;</a></span>iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::iterator =  typename Vec::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00236">236</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="a9db9596845180652ad8b36774d6d9b30" name="a9db9596845180652ad8b36774d6d9b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db9596845180652ad8b36774d6d9b30">&#9670;&nbsp;</a></span>Ptr <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::Ptr =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00234">234</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="a9db9596845180652ad8b36774d6d9b30" name="a9db9596845180652ad8b36774d6d9b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db9596845180652ad8b36774d6d9b30">&#9670;&nbsp;</a></span>Ptr <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::Ptr =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00234">234</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="a7c63027ad3bccd9ba3a87b2818ecf12a" name="a7c63027ad3bccd9ba3a87b2818ecf12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c63027ad3bccd9ba3a87b2818ecf12a">&#9670;&nbsp;</a></span>reverse_iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::reverse_iterator =  typename Vec::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00238">238</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="a7c63027ad3bccd9ba3a87b2818ecf12a" name="a7c63027ad3bccd9ba3a87b2818ecf12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c63027ad3bccd9ba3a87b2818ecf12a">&#9670;&nbsp;</a></span>reverse_iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::reverse_iterator =  typename Vec::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00238">238</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="ae57b9ddb3cac6283df8b9747dff2e1da" name="ae57b9ddb3cac6283df8b9747dff2e1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57b9ddb3cac6283df8b9747dff2e1da">&#9670;&nbsp;</a></span>Vec <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;<a class="el" href="build_2doxygen_2testing_2072__using_8cpp.html#a1b01c504448c96cd2191a5184dd31acf">::Vec</a> =  <a class="el" href="liblodepng_2lodepng_8cpp.html#ac8c5476186a019b60cc8fd4cc6ea41a1">std::vector</a>&lt;<a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00235">235</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<a id="ae57b9ddb3cac6283df8b9747dff2e1da" name="ae57b9ddb3cac6283df8b9747dff2e1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57b9ddb3cac6283df8b9747dff2e1da">&#9670;&nbsp;</a></span>Vec <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;<a class="el" href="build_2doxygen_2testing_2072__using_8cpp.html#a1b01c504448c96cd2191a5184dd31acf">::Vec</a> =  <a class="el" href="liblodepng_2lodepng_8cpp.html#ac8c5476186a019b60cc8fd4cc6ea41a1">std::vector</a>&lt;<a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00235">235</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a273fe87b60116a378346a858e11e4b6e" name="a273fe87b60116a378346a858e11e4b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273fe87b60116a378346a858e11e4b6e">&#9670;&nbsp;</a></span>add() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds an object reference to the ordered vector if it was not added already. Return true if the reference was added, and false if an object with the same key was already added before </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00284">284</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  285</span>    {</div>
<div class="line"><span class="lineno">  286</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(k)==<span class="keyword">nullptr</span>) <span class="comment">// new element</span></div>
<div class="line"><span class="lineno">  287</span>      {</div>
<div class="line"><span class="lineno">  288</span>        <a class="code hl_variable" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">std::string</a> key(k ? k : <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="lineno">  289</span>        <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.insert({key,obj});</div>
<div class="line"><span class="lineno">  290</span>        <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.push_back(obj);</div>
<div class="line"><span class="lineno">  291</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  292</span>      }</div>
<div class="line"><span class="lineno">  293</span>      <span class="keywordflow">else</span> <span class="comment">// already existing, don&#39;t add</span></div>
<div class="line"><span class="lineno">  294</span>      {</div>
<div class="line"><span class="lineno">  295</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  296</span>      }</div>
<div class="line"><span class="lineno">  297</span>    }</div>
<div class="ttc" id="abuild_2doxygen_2libmscgen_2gd_8h_html_ab316628fa3d58332c1756353c49316c1"><div class="ttname"><a href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a></div><div class="ttdeci">int int char double double int int char * string</div><div class="ttdef"><b>Definition:</b> <a href="build_2doxygen_2libmscgen_2gd_8h_source.html#l00744">gd.h:744</a></div></div>
<div class="ttc" id="aclass_linked_ref_map_html_a1ad918f78e81ed4580bcd9c0654fced1"><div class="ttname"><a href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap::m_entries</a></div><div class="ttdeci">Vec m_entries</div><div class="ttdef"><b>Definition:</b> <a href="build_2doxygen_2src_2linkedmap_8h_source.html#l00385">linkedmap.h:385</a></div></div>
<div class="ttc" id="aclass_linked_ref_map_html_a9f6506fe8d15e7f43f61929560a3c377"><div class="ttname"><a href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap::find</a></div><div class="ttdeci">const T * find(const std::string &amp;key) const</div><div class="ttdef"><b>Definition:</b> <a href="build_2doxygen_2src_2linkedmap_8h_source.html#l00243">linkedmap.h:243</a></div></div>
<div class="ttc" id="aclass_linked_ref_map_html_aa825d33ecc2a6b96492886f163b7d47a"><div class="ttname"><a href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap::m_lookup</a></div><div class="ttdeci">Map m_lookup</div><div class="ttdef"><b>Definition:</b> <a href="build_2doxygen_2src_2linkedmap_8h_source.html#l00384">linkedmap.h:384</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#adab2ba56491a0f74345ef3f38455bcc6">doxmlparser.compound.memberdefType::__init__()</a>, <a class="el" href="class_group_def_impl.html#ac75292b2a93ac9f12d9ba802354d78d8">GroupDefImpl::addClass()</a>, <a class="el" href="class_group_def_impl.html#af0e017c3df8a5b3f3d8371dc31b7e7f4">GroupDefImpl::addConcept()</a>, <a class="el" href="class_group_def_impl.html#aa4bc0fd61cd8c0bb996d162d65b785f4">GroupDefImpl::addExample()</a>, <a class="el" href="class_class_def_impl.html#a415c944c2f29ee2c9a1d91aefd28b0f5">ClassDefImpl::addInnerCompound()</a>, <a class="el" href="class_namespace_def_impl.html#a44f04329a371b0fef85dddf7e82bfa6a">NamespaceDefImpl::addInnerCompound()</a>, <a class="el" href="class_page_def_impl.html#a07406453860eb44ca48ee79266a39c44">PageDefImpl::addInnerCompound()</a>, <a class="el" href="class_group_def_impl.html#aa5185c082a10844cd95abd9ed3bc019b">GroupDefImpl::addNamespace()</a>, <a class="el" href="class_group_def_impl.html#ab38c9d7252219cf8fe47bc5252aef353">GroupDefImpl::addPage()</a>, <a class="el" href="class_file_def_impl.html#ad9fd25c1cb996854e44589501ada1e6a">FileDefImpl::addUsingDeclaration()</a>, <a class="el" href="class_namespace_def_impl.html#a8349694867670a040048317e7036aa33">NamespaceDefImpl::addUsingDeclaration()</a>, <a class="el" href="class_file_def_impl.html#a288d8586626127461c9b5b1ec6e766e5">FileDefImpl::addUsingDirective()</a>, <a class="el" href="class_namespace_def_impl.html#a1c863988cf9e221dbdb32a913fc665e5">NamespaceDefImpl::addUsingDirective()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a525a532678f13c24e28f70aa7ba57a2a">doxmlparser.compound.memberdefType::buildAttributes()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#aef6554e5a3b993d4b43b324e67741192">doxmlparser.compound.memberdefType::exportAttributes()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a60a044d80141a7150d145b81eeb00830">doxmlparser.compound.memberdefType::get_add()</a>, <a class="el" href="class_file_def_impl.html#afdadb15408e8d2eeb57937c0cb06ca20">FileDefImpl::insertClass()</a>, <a class="el" href="class_namespace_def_impl.html#abdab8bd9e7ec5cdd788bb72fca20800c">NamespaceDefImpl::insertClass()</a>, <a class="el" href="class_file_def_impl.html#af8e324cde84f92d2f99c61f8992d1ab5">FileDefImpl::insertConcept()</a>, <a class="el" href="class_namespace_def_impl.html#adf0792429190111979848f763ab16898">NamespaceDefImpl::insertConcept()</a>, <a class="el" href="class_namespace_def_impl.html#a4db9f2bd68ed096fd03c6896e93dc1ce">NamespaceDefImpl::insertMember()</a>, <a class="el" href="class_file_def_impl.html#a1759b18703d217242f19747c80196dda">FileDefImpl::insertNamespace()</a>, <a class="el" href="class_namespace_def_impl.html#ac5cfb1eda350a6103986a89cb3880c91">NamespaceDefImpl::insertNamespace()</a>, and <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a2cbc698579f967bd2fd50750b3efd3fb">doxmlparser.compound.memberdefType::set_add()</a>.</p>

</div>
</div>
<a id="a273fe87b60116a378346a858e11e4b6e" name="a273fe87b60116a378346a858e11e4b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273fe87b60116a378346a858e11e4b6e">&#9670;&nbsp;</a></span>add() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds an object reference to the ordered vector if it was not added already. Return true if the reference was added, and false if an object with the same key was already added before </p>

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00284">284</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  285</span>    {</div>
<div class="line"><span class="lineno">  286</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(k)==<span class="keyword">nullptr</span>) <span class="comment">// new element</span></div>
<div class="line"><span class="lineno">  287</span>      {</div>
<div class="line"><span class="lineno">  288</span>        <a class="code hl_variable" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">std::string</a> key(k ? k : <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="lineno">  289</span>        <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.insert({key,obj});</div>
<div class="line"><span class="lineno">  290</span>        <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.push_back(obj);</div>
<div class="line"><span class="lineno">  291</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  292</span>      }</div>
<div class="line"><span class="lineno">  293</span>      <span class="keywordflow">else</span> <span class="comment">// already existing, don&#39;t add</span></div>
<div class="line"><span class="lineno">  294</span>      {</div>
<div class="line"><span class="lineno">  295</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  296</span>      }</div>
<div class="line"><span class="lineno">  297</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#adab2ba56491a0f74345ef3f38455bcc6">doxmlparser.compound.memberdefType::__init__()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a525a532678f13c24e28f70aa7ba57a2a">doxmlparser.compound.memberdefType::buildAttributes()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#aef6554e5a3b993d4b43b324e67741192">doxmlparser.compound.memberdefType::exportAttributes()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a60a044d80141a7150d145b81eeb00830">doxmlparser.compound.memberdefType::get_add()</a>, and <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a2cbc698579f967bd2fd50750b3efd3fb">doxmlparser.compound.memberdefType::set_add()</a>.</p>

</div>
</div>
<a id="acaf21f8a88dc994cf1de14246e679579" name="acaf21f8a88dc994cf1de14246e679579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf21f8a88dc994cf1de14246e679579">&#9670;&nbsp;</a></span>add() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00299">299</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  300</span>    {</div>
<div class="line"><span class="lineno">  301</span>      <a class="code hl_variable" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">std::string</a> key = k.<a class="code hl_function" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">str</a>();</div>
<div class="line"><span class="lineno">  302</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key)==<span class="keyword">nullptr</span>) <span class="comment">// new element</span></div>
<div class="line"><span class="lineno">  303</span>      {</div>
<div class="line"><span class="lineno">  304</span>        <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.insert({key,obj});</div>
<div class="line"><span class="lineno">  305</span>        <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.push_back(obj);</div>
<div class="line"><span class="lineno">  306</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  307</span>      }</div>
<div class="line"><span class="lineno">  308</span>      <span class="keywordflow">else</span> <span class="comment">// already existing, don&#39;t add</span></div>
<div class="line"><span class="lineno">  309</span>      {</div>
<div class="line"><span class="lineno">  310</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  311</span>      }</div>
<div class="line"><span class="lineno">  312</span>    }</div>
<div class="ttc" id="aclass_q_c_string_html_a875e9ad762554ef12f3ed69b015bb245"><div class="ttname"><a href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str</a></div><div class="ttdeci">const std::string &amp; str() const</div><div class="ttdef"><b>Definition:</b> <a href="build_2doxygen_2src_2qcstring_8h_source.html#l00480">qcstring.h:480</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, <a class="el" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str()</a>, and <a class="el" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#adab2ba56491a0f74345ef3f38455bcc6">doxmlparser.compound.memberdefType::__init__()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a525a532678f13c24e28f70aa7ba57a2a">doxmlparser.compound.memberdefType::buildAttributes()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#aef6554e5a3b993d4b43b324e67741192">doxmlparser.compound.memberdefType::exportAttributes()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a60a044d80141a7150d145b81eeb00830">doxmlparser.compound.memberdefType::get_add()</a>, and <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a2cbc698579f967bd2fd50750b3efd3fb">doxmlparser.compound.memberdefType::set_add()</a>.</p>

</div>
</div>
<a id="acaf21f8a88dc994cf1de14246e679579" name="acaf21f8a88dc994cf1de14246e679579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf21f8a88dc994cf1de14246e679579">&#9670;&nbsp;</a></span>add() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00299">299</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  300</span>    {</div>
<div class="line"><span class="lineno">  301</span>      <a class="code hl_variable" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">std::string</a> key = k.<a class="code hl_function" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">str</a>();</div>
<div class="line"><span class="lineno">  302</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key)==<span class="keyword">nullptr</span>) <span class="comment">// new element</span></div>
<div class="line"><span class="lineno">  303</span>      {</div>
<div class="line"><span class="lineno">  304</span>        <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.insert({key,obj});</div>
<div class="line"><span class="lineno">  305</span>        <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.push_back(obj);</div>
<div class="line"><span class="lineno">  306</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  307</span>      }</div>
<div class="line"><span class="lineno">  308</span>      <span class="keywordflow">else</span> <span class="comment">// already existing, don&#39;t add</span></div>
<div class="line"><span class="lineno">  309</span>      {</div>
<div class="line"><span class="lineno">  310</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  311</span>      }</div>
<div class="line"><span class="lineno">  312</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, <a class="el" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str()</a>, and <a class="el" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#adab2ba56491a0f74345ef3f38455bcc6">doxmlparser.compound.memberdefType::__init__()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a525a532678f13c24e28f70aa7ba57a2a">doxmlparser.compound.memberdefType::buildAttributes()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#aef6554e5a3b993d4b43b324e67741192">doxmlparser.compound.memberdefType::exportAttributes()</a>, <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a60a044d80141a7150d145b81eeb00830">doxmlparser.compound.memberdefType::get_add()</a>, and <a class="el" href="classdoxmlparser_1_1compound_1_1memberdef_type.html#a2cbc698579f967bd2fd50750b3efd3fb">doxmlparser.compound.memberdefType::set_add()</a>.</p>

</div>
</div>
<a id="ac2f30ce85fd85bfb75bcb56bd10fe9a4" name="ac2f30ce85fd85bfb75bcb56bd10fe9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f30ce85fd85bfb75bcb56bd10fe9a4">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00366">366</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  366</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.begin();   }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_class_def_impl.html#acfa5f797e97e3b9f969f0ec8c3e44de7">ClassDefImpl::sortMemberLists()</a>, <a class="el" href="class_file_def_impl.html#a202c125c99bc2aad6c52352e2b11ca09">FileDefImpl::sortMemberLists()</a>, <a class="el" href="class_group_def_impl.html#ab80c1b20a32942019d509e08a6693cdd">GroupDefImpl::sortMemberLists()</a>, and <a class="el" href="class_namespace_def_impl.html#ad22dc13b15dbb0fd45250f3d626b08b8">NamespaceDefImpl::sortMemberLists()</a>.</p>

</div>
</div>
<a id="ac2f30ce85fd85bfb75bcb56bd10fe9a4" name="ac2f30ce85fd85bfb75bcb56bd10fe9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f30ce85fd85bfb75bcb56bd10fe9a4">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00366">366</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  366</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.begin();   }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a77a3307eb17ea829836140639cb52115" name="a77a3307eb17ea829836140639cb52115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a3307eb17ea829836140639cb52115">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00368">368</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  368</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.cbegin();  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a77a3307eb17ea829836140639cb52115" name="a77a3307eb17ea829836140639cb52115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a3307eb17ea829836140639cb52115">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00368">368</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  368</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.cbegin();  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="ad67fa2110f306614b020782b88c28c83" name="ad67fa2110f306614b020782b88c28c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67fa2110f306614b020782b88c28c83">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00377">377</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  378</span>    {</div>
<div class="line"><span class="lineno">  379</span>      <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.clear();</div>
<div class="line"><span class="lineno">  380</span>      <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.clear();</div>
<div class="line"><span class="lineno">  381</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, and <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>.</p>

</div>
</div>
<a id="ad67fa2110f306614b020782b88c28c83" name="ad67fa2110f306614b020782b88c28c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67fa2110f306614b020782b88c28c83">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00377">377</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  378</span>    {</div>
<div class="line"><span class="lineno">  379</span>      <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.clear();</div>
<div class="line"><span class="lineno">  380</span>      <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.clear();</div>
<div class="line"><span class="lineno">  381</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, and <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>.</p>

</div>
</div>
<a id="a5fad70772de2ff561c5883f5a8919c5d" name="a5fad70772de2ff561c5883f5a8919c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fad70772de2ff561c5883f5a8919c5d">&#9670;&nbsp;</a></span>del() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::del </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Removes an object from the container and deletes it. Returns true if the object was deleted or false it is was not found. </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00348">348</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  349</span>    {</div>
<div class="line"><span class="lineno">  350</span>      <span class="keyword">auto</span> it = <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.find(key.<a class="code hl_function" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">str</a>());</div>
<div class="line"><span class="lineno">  351</span>      <span class="keywordflow">if</span> (it!=<a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.end())</div>
<div class="line"><span class="lineno">  352</span>      {</div>
<div class="line"><span class="lineno">  353</span>        <span class="keyword">auto</span> vecit = std::find_if(<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.begin(),<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.end(),[obj=it-&gt;second](<span class="keyword">auto</span> &amp;el) { return el.get()==obj; });</div>
<div class="line"><span class="lineno">  354</span>        <span class="keywordflow">if</span> (vecit!=<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.end()) <span class="comment">// should always be true</span></div>
<div class="line"><span class="lineno">  355</span>        {</div>
<div class="line"><span class="lineno">  356</span>          <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.erase(vecit);</div>
<div class="line"><span class="lineno">  357</span>          <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.erase(it);</div>
<div class="line"><span class="lineno">  358</span>          <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  359</span>        }</div>
<div class="line"><span class="lineno">  360</span>      }</div>
<div class="line"><span class="lineno">  361</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  362</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str()</a>.</p>

</div>
</div>
<a id="a5fad70772de2ff561c5883f5a8919c5d" name="a5fad70772de2ff561c5883f5a8919c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fad70772de2ff561c5883f5a8919c5d">&#9670;&nbsp;</a></span>del() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::del </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Removes an object from the container and deletes it. Returns true if the object was deleted or false it is was not found. </p>

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00348">348</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  349</span>    {</div>
<div class="line"><span class="lineno">  350</span>      <span class="keyword">auto</span> it = <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.find(key.<a class="code hl_function" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">str</a>());</div>
<div class="line"><span class="lineno">  351</span>      <span class="keywordflow">if</span> (it!=<a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.end())</div>
<div class="line"><span class="lineno">  352</span>      {</div>
<div class="line"><span class="lineno">  353</span>        <span class="keyword">auto</span> vecit = std::find_if(<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.begin(),<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.end(),[obj=it-&gt;second](<span class="keyword">auto</span> &amp;el) { return el.get()==obj; });</div>
<div class="line"><span class="lineno">  354</span>        <span class="keywordflow">if</span> (vecit!=<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.end()) <span class="comment">// should always be true</span></div>
<div class="line"><span class="lineno">  355</span>        {</div>
<div class="line"><span class="lineno">  356</span>          <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.erase(vecit);</div>
<div class="line"><span class="lineno">  357</span>          <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.erase(it);</div>
<div class="line"><span class="lineno">  358</span>          <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  359</span>        }</div>
<div class="line"><span class="lineno">  360</span>      }</div>
<div class="line"><span class="lineno">  361</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  362</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str()</a>.</p>

</div>
</div>
<a id="ad4eea714e29d412612981ac2a8bcab40" name="ad4eea714e29d412612981ac2a8bcab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eea714e29d412612981ac2a8bcab40">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00374">374</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  374</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.empty();   }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_nesting_node_context_1_1_private.html#abdda7ed01aaab83089666dff576aa169">NestingNodeContext::Private::addNamespaces()</a>, <a class="el" href="class_nesting_node_context_1_1_private.html#a8738718f7561bd84e65e18c9baa085ff">NestingNodeContext::Private::addPages()</a>, <a class="el" href="class_namespace_def_impl.html#a03d294d7649af63285227d0e96c5cff7">NamespaceDefImpl::findInnerCompound()</a>, <a class="el" href="build_2doxygen_2src_2doxygen_8cpp.html#a8cb9252694dc27b52bd30efe903f9654">findScopeFromQualifiedName()</a>, <a class="el" href="class_perl_mod_generator.html#aa29eb86a9962f547f8139ff1cfe40b01">PerlModGenerator::generatePerlModForGroup()</a>, <a class="el" href="class_perl_mod_generator.html#a6d79f62a76314d0c65cb976809923d80">PerlModGenerator::generatePerlModForNamespace()</a>, <a class="el" href="struct_symbol_resolver_1_1_private.html#a4b1064343083d6422f200e907d7fea1f">SymbolResolver::Private::getResolvedTypeRec()</a>, <a class="el" href="class_page_def_impl.html#a2696200478bfc323d4ff5ca5f2220109">PageDefImpl::hasSubPages()</a>, <a class="el" href="build_2doxygen_2src_2doxygen_8cpp.html#a39bb7d9a1e431158cb3a423215f044bb">processTagLessClasses()</a>, and <a class="el" href="build_2doxygen_2src_2index_8cpp.html#ae2c24526468232c3a2c4f93669225392">writeGroupTreeNode()</a>.</p>

</div>
</div>
<a id="ad4eea714e29d412612981ac2a8bcab40" name="ad4eea714e29d412612981ac2a8bcab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eea714e29d412612981ac2a8bcab40">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00374">374</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  374</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.empty();   }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a7d843d470df85d608d8d47b2a56c5e80" name="a7d843d470df85d608d8d47b2a56c5e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d843d470df85d608d8d47b2a56c5e80">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00367">367</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  367</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.end();     }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_class_def_impl.html#acfa5f797e97e3b9f969f0ec8c3e44de7">ClassDefImpl::sortMemberLists()</a>, <a class="el" href="class_file_def_impl.html#a202c125c99bc2aad6c52352e2b11ca09">FileDefImpl::sortMemberLists()</a>, <a class="el" href="class_group_def_impl.html#ab80c1b20a32942019d509e08a6693cdd">GroupDefImpl::sortMemberLists()</a>, and <a class="el" href="class_namespace_def_impl.html#ad22dc13b15dbb0fd45250f3d626b08b8">NamespaceDefImpl::sortMemberLists()</a>.</p>

</div>
</div>
<a id="a7d843d470df85d608d8d47b2a56c5e80" name="a7d843d470df85d608d8d47b2a56c5e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d843d470df85d608d8d47b2a56c5e80">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#aee7c1420984bc5d41ef945689343be5c">iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00367">367</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  367</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.end();     }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a6fed959ab40da898bbebfdb3c8653b2c" name="a6fed959ab40da898bbebfdb3c8653b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fed959ab40da898bbebfdb3c8653b2c">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00369">369</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  369</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.cend();    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a6fed959ab40da898bbebfdb3c8653b2c" name="a6fed959ab40da898bbebfdb3c8653b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fed959ab40da898bbebfdb3c8653b2c">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#ae9d600d6dc898d3efd063381f60eaaf7">const_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00369">369</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  369</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.cend();    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a0e393b31c768a9de5d04455a8596e1a9" name="a0e393b31c768a9de5d04455a8596e1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e393b31c768a9de5d04455a8596e1a9">&#9670;&nbsp;</a></span>find() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non-const wrapper for find() const </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00265">265</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  266</span>    {</div>
<div class="line"><span class="lineno">  267</span>      <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_linked_ref_map.html">LinkedRefMap</a>&amp;<span class="keyword">&gt;</span>(*this).<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key));</div>
<div class="line"><span class="lineno">  268</span>    }</div>
<div class="ttc" id="aclass_linked_ref_map_html"><div class="ttname"><a href="class_linked_ref_map.html">LinkedRefMap</a></div><div class="ttdoc">Container class representing a vector of objects with keys.</div><div class="ttdef"><b>Definition:</b> <a href="build_2doxygen_2src_2linkedmap_8h_source.html#l00231">linkedmap.h:232</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>.</p>

</div>
</div>
<a id="a0e393b31c768a9de5d04455a8596e1a9" name="a0e393b31c768a9de5d04455a8596e1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e393b31c768a9de5d04455a8596e1a9">&#9670;&nbsp;</a></span>find() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non-const wrapper for find() const </p>

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00265">265</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  266</span>    {</div>
<div class="line"><span class="lineno">  267</span>      <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_linked_ref_map.html">LinkedRefMap</a>&amp;<span class="keyword">&gt;</span>(*this).<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key));</div>
<div class="line"><span class="lineno">  268</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>.</p>

</div>
</div>
<a id="aed765c5f6f6956643f0753c9ea1d714e" name="aed765c5f6f6956643f0753c9ea1d714e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed765c5f6f6956643f0753c9ea1d714e">&#9670;&nbsp;</a></span>find() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00259">259</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  260</span>    {</div>
<div class="line"><span class="lineno">  261</span>      <span class="keywordflow">return</span> <a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(<a class="code hl_variable" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">std::string</a>(key ? key : <span class="stringliteral">&quot;&quot;</span>));</div>
<div class="line"><span class="lineno">  262</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, and <a class="el" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a>.</p>

</div>
</div>
<a id="aed765c5f6f6956643f0753c9ea1d714e" name="aed765c5f6f6956643f0753c9ea1d714e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed765c5f6f6956643f0753c9ea1d714e">&#9670;&nbsp;</a></span>find() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00259">259</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  260</span>    {</div>
<div class="line"><span class="lineno">  261</span>      <span class="keywordflow">return</span> <a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(<a class="code hl_variable" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">std::string</a>(key ? key : <span class="stringliteral">&quot;&quot;</span>));</div>
<div class="line"><span class="lineno">  262</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, and <a class="el" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a>.</p>

</div>
</div>
<a id="a2f413af4720b2f575c911b78ee3a70b1" name="a2f413af4720b2f575c911b78ee3a70b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f413af4720b2f575c911b78ee3a70b1">&#9670;&nbsp;</a></span>find() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00270">270</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  271</span>    {</div>
<div class="line"><span class="lineno">  272</span>      <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_linked_ref_map.html">LinkedRefMap</a>&amp;<span class="keyword">&gt;</span>(*this).<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key));</div>
<div class="line"><span class="lineno">  273</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>.</p>

</div>
</div>
<a id="a2f413af4720b2f575c911b78ee3a70b1" name="a2f413af4720b2f575c911b78ee3a70b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f413af4720b2f575c911b78ee3a70b1">&#9670;&nbsp;</a></span>find() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00270">270</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  271</span>    {</div>
<div class="line"><span class="lineno">  272</span>      <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_linked_ref_map.html">LinkedRefMap</a>&amp;<span class="keyword">&gt;</span>(*this).<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key));</div>
<div class="line"><span class="lineno">  273</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>.</p>

</div>
</div>
<a id="a3d3f8cefe5cfd6d46e95889817b92140" name="a3d3f8cefe5cfd6d46e95889817b92140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3f8cefe5cfd6d46e95889817b92140">&#9670;&nbsp;</a></span>find() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00251">251</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  252</span>    {</div>
<div class="line"><span class="lineno">  253</span>      <span class="keyword">auto</span> it = <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.find(key.<a class="code hl_function" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">str</a>());</div>
<div class="line"><span class="lineno">  254</span>      <span class="keywordflow">return</span> it!=<a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.end() ? it-&gt;second : <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  255</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str()</a>.</p>

</div>
</div>
<a id="a3d3f8cefe5cfd6d46e95889817b92140" name="a3d3f8cefe5cfd6d46e95889817b92140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3f8cefe5cfd6d46e95889817b92140">&#9670;&nbsp;</a></span>find() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00251">251</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  252</span>    {</div>
<div class="line"><span class="lineno">  253</span>      <span class="keyword">auto</span> it = <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.find(key.<a class="code hl_function" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">str</a>());</div>
<div class="line"><span class="lineno">  254</span>      <span class="keywordflow">return</span> it!=<a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.end() ? it-&gt;second : <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  255</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str()</a>.</p>

</div>
</div>
<a id="a6dab86c77d6037d5fc0be82fca6e1587" name="a6dab86c77d6037d5fc0be82fca6e1587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab86c77d6037d5fc0be82fca6e1587">&#9670;&nbsp;</a></span>find() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmscgen_2gd_8h.html#a13690c1a2aacb1c8261e3be3c4a4f4b2">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non-const wrapper for find() const </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00276">276</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  277</span>    {</div>
<div class="line"><span class="lineno">  278</span>      <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_linked_ref_map.html">LinkedRefMap</a>&amp;<span class="keyword">&gt;</span>(*this).<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key));</div>
<div class="line"><span class="lineno">  279</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>.</p>

</div>
</div>
<a id="a6dab86c77d6037d5fc0be82fca6e1587" name="a6dab86c77d6037d5fc0be82fca6e1587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab86c77d6037d5fc0be82fca6e1587">&#9670;&nbsp;</a></span>find() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmscgen_2gd_8h.html#a13690c1a2aacb1c8261e3be3c4a4f4b2">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>non-const wrapper for find() const </p>

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00276">276</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  277</span>    {</div>
<div class="line"><span class="lineno">  278</span>      <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_linked_ref_map.html">LinkedRefMap</a>&amp;<span class="keyword">&gt;</span>(*this).<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key));</div>
<div class="line"><span class="lineno">  279</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>.</p>

</div>
</div>
<a id="a9f6506fe8d15e7f43f61929560a3c377" name="a9f6506fe8d15e7f43f61929560a3c377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6506fe8d15e7f43f61929560a3c377">&#9670;&nbsp;</a></span>find() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmscgen_2gd_8h.html#a13690c1a2aacb1c8261e3be3c4a4f4b2">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00243">243</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  244</span>    {</div>
<div class="line"><span class="lineno">  245</span>      <span class="keyword">auto</span> it = <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.find(key);</div>
<div class="line"><span class="lineno">  246</span>      <span class="keywordflow">return</span> it!=<a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.end() ? it-&gt;second : <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  247</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_linked_ref_map.html#a273fe87b60116a378346a858e11e4b6e">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::add()</a>, <a class="el" href="class_group_def_impl.html#ac75292b2a93ac9f12d9ba802354d78d8">GroupDefImpl::addClass()</a>, <a class="el" href="class_group_def_impl.html#af0e017c3df8a5b3f3d8371dc31b7e7f4">GroupDefImpl::addConcept()</a>, <a class="el" href="class_class_def_impl.html#a97e537f74ce79123894794ee150ab2ec">ClassDefImpl::addMembersToTemplateInstance()</a>, <a class="el" href="class_group_def_impl.html#aa5185c082a10844cd95abd9ed3bc019b">GroupDefImpl::addNamespace()</a>, <a class="el" href="class_linked_ref_map.html#aed765c5f6f6956643f0753c9ea1d714e">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="build_2doxygen_2src_2doxygen_8cpp.html#a18307d943d41d2ed5849c6faf3d02a1d">findGlobalMember()</a>, <a class="el" href="class_class_def_impl.html#a7c2707efa830fbb93d1869967761f8af">ClassDefImpl::findInnerCompound()</a>, <a class="el" href="class_namespace_def_impl.html#a03d294d7649af63285227d0e96c5cff7">NamespaceDefImpl::findInnerCompound()</a>, <a class="el" href="class_namespace_def_impl.html#aae2c52fb21e4d7d03ca4b6c4d748f335">NamespaceDefImpl::getMemberByName()</a>, and <a class="el" href="class_linked_ref_map.html#a821db7bc14f1498938bd5314502f3655">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::prepend()</a>.</p>

</div>
</div>
<a id="a9f6506fe8d15e7f43f61929560a3c377" name="a9f6506fe8d15e7f43f61929560a3c377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6506fe8d15e7f43f61929560a3c377">&#9670;&nbsp;</a></span>find() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmscgen_2gd_8h.html#a13690c1a2aacb1c8261e3be3c4a4f4b2">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >find an object given the key. Returns a pointer to the object if found or nullptr if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00243">243</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  244</span>    {</div>
<div class="line"><span class="lineno">  245</span>      <span class="keyword">auto</span> it = <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.find(key);</div>
<div class="line"><span class="lineno">  246</span>      <span class="keywordflow">return</span> it!=<a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.end() ? it-&gt;second : <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  247</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>.</p>

</div>
</div>
<a id="a89581f93afd0740dee45e136d1a54546" name="a89581f93afd0740dee45e136d1a54546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89581f93afd0740dee45e136d1a54546">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp; <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00364">364</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  364</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>[pos];      }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a89581f93afd0740dee45e136d1a54546" name="a89581f93afd0740dee45e136d1a54546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89581f93afd0740dee45e136d1a54546">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp; <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00364">364</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  364</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>[pos];      }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a09d227163284233b8e37f3a265510b49" name="a09d227163284233b8e37f3a265510b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d227163284233b8e37f3a265510b49">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp; <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00365">365</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  365</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>[pos];      }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a09d227163284233b8e37f3a265510b49" name="a09d227163284233b8e37f3a265510b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d227163284233b8e37f3a265510b49">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_linked_ref_map.html#a9db9596845180652ad8b36774d6d9b30">Ptr</a> &amp; <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00365">365</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  365</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>[pos];      }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a821db7bc14f1498938bd5314502f3655" name="a821db7bc14f1498938bd5314502f3655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821db7bc14f1498938bd5314502f3655">&#9670;&nbsp;</a></span>prepend() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Prepends an object reference to the ordered vector if it was not added already. Return true if the reference was added, and false if an object with the same key was already added before </p>

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00317">317</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  318</span>    {</div>
<div class="line"><span class="lineno">  319</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(k)==<span class="keyword">nullptr</span>) <span class="comment">// new element</span></div>
<div class="line"><span class="lineno">  320</span>      {</div>
<div class="line"><span class="lineno">  321</span>        <a class="code hl_variable" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">std::string</a> key(k ? k : <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="lineno">  322</span>        <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.insert({key,obj});</div>
<div class="line"><span class="lineno">  323</span>        <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.insert(<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.begin(),obj);</div>
<div class="line"><span class="lineno">  324</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  325</span>      }</div>
<div class="line"><span class="lineno">  326</span>      <span class="keywordflow">else</span> <span class="comment">// already existing, don&#39;t add</span></div>
<div class="line"><span class="lineno">  327</span>      {</div>
<div class="line"><span class="lineno">  328</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  329</span>      }</div>
<div class="line"><span class="lineno">  330</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_file_def_impl.html#a9c9a752b565f72e4c5714c6ebaf16578">FileDefImpl::addIncludedUsingDirectives()</a>.</p>

</div>
</div>
<a id="a821db7bc14f1498938bd5314502f3655" name="a821db7bc14f1498938bd5314502f3655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821db7bc14f1498938bd5314502f3655">&#9670;&nbsp;</a></span>prepend() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Prepends an object reference to the ordered vector if it was not added already. Return true if the reference was added, and false if an object with the same key was already added before </p>

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00317">317</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  318</span>    {</div>
<div class="line"><span class="lineno">  319</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(k)==<span class="keyword">nullptr</span>) <span class="comment">// new element</span></div>
<div class="line"><span class="lineno">  320</span>      {</div>
<div class="line"><span class="lineno">  321</span>        <a class="code hl_variable" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">std::string</a> key(k ? k : <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="lineno">  322</span>        <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.insert({key,obj});</div>
<div class="line"><span class="lineno">  323</span>        <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.insert(<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.begin(),obj);</div>
<div class="line"><span class="lineno">  324</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  325</span>      }</div>
<div class="line"><span class="lineno">  326</span>      <span class="keywordflow">else</span> <span class="comment">// already existing, don&#39;t add</span></div>
<div class="line"><span class="lineno">  327</span>      {</div>
<div class="line"><span class="lineno">  328</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  329</span>      }</div>
<div class="line"><span class="lineno">  330</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="build_2doxygen_2libmscgen_2gd_8h.html#ab316628fa3d58332c1756353c49316c1">string</a>.</p>

</div>
</div>
<a id="a98b0589fd4091da2efa1c5ee2da43f73" name="a98b0589fd4091da2efa1c5ee2da43f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b0589fd4091da2efa1c5ee2da43f73">&#9670;&nbsp;</a></span>prepend() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00332">332</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  333</span>    {</div>
<div class="line"><span class="lineno">  334</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key)==<span class="keyword">nullptr</span>) <span class="comment">// new element</span></div>
<div class="line"><span class="lineno">  335</span>      {</div>
<div class="line"><span class="lineno">  336</span>        <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.insert({key.<a class="code hl_function" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">str</a>(),obj});</div>
<div class="line"><span class="lineno">  337</span>        <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.insert(<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.begin(),obj);</div>
<div class="line"><span class="lineno">  338</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  339</span>      }</div>
<div class="line"><span class="lineno">  340</span>      <span class="keywordflow">else</span> <span class="comment">// already existing, don&#39;t add</span></div>
<div class="line"><span class="lineno">  341</span>      {</div>
<div class="line"><span class="lineno">  342</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  343</span>      }</div>
<div class="line"><span class="lineno">  344</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str()</a>.</p>

</div>
</div>
<a id="a98b0589fd4091da2efa1c5ee2da43f73" name="a98b0589fd4091da2efa1c5ee2da43f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b0589fd4091da2efa1c5ee2da43f73">&#9670;&nbsp;</a></span>prepend() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::prepend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_c_string.html">QCString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00332">332</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  333</span>    {</div>
<div class="line"><span class="lineno">  334</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">find</a>(key)==<span class="keyword">nullptr</span>) <span class="comment">// new element</span></div>
<div class="line"><span class="lineno">  335</span>      {</div>
<div class="line"><span class="lineno">  336</span>        <a class="code hl_variable" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">m_lookup</a>.insert({key.<a class="code hl_function" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">str</a>(),obj});</div>
<div class="line"><span class="lineno">  337</span>        <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.insert(<a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.begin(),obj);</div>
<div class="line"><span class="lineno">  338</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  339</span>      }</div>
<div class="line"><span class="lineno">  340</span>      <span class="keywordflow">else</span> <span class="comment">// already existing, don&#39;t add</span></div>
<div class="line"><span class="lineno">  341</span>      {</div>
<div class="line"><span class="lineno">  342</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  343</span>      }</div>
<div class="line"><span class="lineno">  344</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>, <a class="el" href="class_linked_ref_map.html#aa825d33ecc2a6b96492886f163b7d47a">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</a>, and <a class="el" href="class_q_c_string.html#a875e9ad762554ef12f3ed69b015bb245">QCString::str()</a>.</p>

</div>
</div>
<a id="ac971d2e3cc8e2651f5648b6946b25bd7" name="ac971d2e3cc8e2651f5648b6946b25bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac971d2e3cc8e2651f5648b6946b25bd7">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00370">370</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  370</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.rbegin();  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="ac971d2e3cc8e2651f5648b6946b25bd7" name="ac971d2e3cc8e2651f5648b6946b25bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac971d2e3cc8e2651f5648b6946b25bd7">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00370">370</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  370</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.rbegin();  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a2d088d23b0ce73cf2ed3b8cfc2fbe89d" name="a2d088d23b0ce73cf2ed3b8cfc2fbe89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d088d23b0ce73cf2ed3b8cfc2fbe89d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00372">372</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  372</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.crbegin(); }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a2d088d23b0ce73cf2ed3b8cfc2fbe89d" name="a2d088d23b0ce73cf2ed3b8cfc2fbe89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d088d23b0ce73cf2ed3b8cfc2fbe89d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00372">372</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  372</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.crbegin(); }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a2a306a67c71e29179b309647309d6e96" name="a2a306a67c71e29179b309647309d6e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a306a67c71e29179b309647309d6e96">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00371">371</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  371</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.rend();    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a2a306a67c71e29179b309647309d6e96" name="a2a306a67c71e29179b309647309d6e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a306a67c71e29179b309647309d6e96">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a7c63027ad3bccd9ba3a87b2818ecf12a">reverse_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00371">371</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  371</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.rend();    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="ab67fb1418120d42cf91a2a033a6b16ad" name="ab67fb1418120d42cf91a2a033a6b16ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67fb1418120d42cf91a2a033a6b16ad">&#9670;&nbsp;</a></span>rend() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00373">373</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  373</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.crend();   }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="ab67fb1418120d42cf91a2a033a6b16ad" name="ab67fb1418120d42cf91a2a033a6b16ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67fb1418120d42cf91a2a033a6b16ad">&#9670;&nbsp;</a></span>rend() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#a5d04d68baaeb769cfe0e3cfa9873e40f">const_reverse_iterator</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00373">373</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  373</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.crend();   }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<a id="a5fe0b41a59bcf683e2ade44911a3fe1d" name="a5fe0b41a59bcf683e2ade44911a3fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe0b41a59bcf683e2ade44911a3fe1d">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00375">375</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  375</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.size();    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_class_context_1_1_private.html#a41287dad7118dcd4870d7e16c93e3f97">ClassContext::Private::createClasses()</a>, <a class="el" href="class_namespace_context_1_1_private.html#af677f949d9c4d914838511532f389875">NamespaceContext::Private::createClasses()</a>, <a class="el" href="class_file_context_1_1_private.html#ab770596a2548520cc1c9b372445e6f6e">FileContext::Private::createClasses()</a>, <a class="el" href="class_module_context_1_1_private.html#a8d4cde27b120f26041a501e76a22423c">ModuleContext::Private::createClasses()</a>, <a class="el" href="class_namespace_context_1_1_private.html#ada4d7bf8a742893aa8a0e1d9425c6ae1">NamespaceContext::Private::createConstantgroups()</a>, <a class="el" href="class_file_context_1_1_private.html#aa8fb747926c28a82e232d0c015a7bffc">FileContext::Private::createConstantgroups()</a>, <a class="el" href="class_module_context_1_1_private.html#ab0f5d7563e8f89c1396d8385834f349c">ModuleContext::Private::createConstantgroups()</a>, <a class="el" href="class_module_context_1_1_private.html#a53af6369e8fd9b73e77ec7aeb20b408f">ModuleContext::Private::createExamples()</a>, <a class="el" href="class_namespace_context_1_1_private.html#a785fe9497f70391ce88408335a47a6fd">NamespaceContext::Private::createInlineClasses()</a>, <a class="el" href="class_file_context_1_1_private.html#a392c2006da93381dd57f813c4d829c79">FileContext::Private::createInlineClasses()</a>, <a class="el" href="class_class_context_1_1_private.html#a61b334436b23f720b14813ad120e18ff">ClassContext::Private::createInnerClasses()</a>, <a class="el" href="class_namespace_context_1_1_private.html#a43d2c57a7d589dc4050fc371e8530e75">NamespaceContext::Private::createNamespaces()</a>, <a class="el" href="class_file_context_1_1_private.html#a3a1c5474dd46a801605cd79f033b741e">FileContext::Private::createNamespaces()</a>, <a class="el" href="class_module_context_1_1_private.html#ad547c5118860e5af3bffe5a1880dbba0">ModuleContext::Private::createNamespaces()</a>, <a class="el" href="class_module_context_1_1_private.html#a702a2523f8e6ff655873dbfc2255c71b">ModuleContext::Private::createPages()</a>, <a class="el" href="class_group_def_impl.html#a486f0e82fee974f2d9a96698b6692251">GroupDefImpl::hasDetailedDescription()</a>, <a class="el" href="addon_2doxyapp_2doxyapp_8cpp.html#aa4c33ab9f156126cd1c2e40947af1f70">lookupSymbol()</a>, <a class="el" href="class_group_def_impl.html#a64b1c64d66a12b55f0dcb4bb5c88b19a">GroupDefImpl::numDocMembers()</a>, <a class="el" href="class_namespace_def_impl.html#ab9bda894bcb77b933cd7f7811befb336">NamespaceDefImpl::numDocMembers()</a>, <a class="el" href="class_group_def_impl.html#ad25697fdd0818627cd818c3dee5ca950">GroupDefImpl::writeDetailedDescription()</a>, and <a class="el" href="build_2doxygen_2src_2index_8cpp.html#ae2c24526468232c3a2c4f93669225392">writeGroupTreeNode()</a>.</p>

</div>
</div>
<a id="a5fe0b41a59bcf683e2ade44911a3fe1d" name="a5fe0b41a59bcf683e2ade44911a3fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe0b41a59bcf683e2ade44911a3fe1d">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2linkedmap_8h_source.html#l00375">375</a> of file <a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  375</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">m_entries</a>.size();    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_linked_ref_map.html#a1ad918f78e81ed4580bcd9c0654fced1">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::m_entries</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1ad918f78e81ed4580bcd9c0654fced1" name="a1ad918f78e81ed4580bcd9c0654fced1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad918f78e81ed4580bcd9c0654fced1">&#9670;&nbsp;</a></span>m_entries</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_linked_ref_map.html#ae57b9ddb3cac6283df8b9747dff2e1da">Vec</a> <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::m_entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00385">385</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_linked_ref_map.html#a273fe87b60116a378346a858e11e4b6e">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::add()</a>, <a class="el" href="class_linked_ref_map.html#ac2f30ce85fd85bfb75bcb56bd10fe9a4">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::begin()</a>, <a class="el" href="class_linked_ref_map.html#ad67fa2110f306614b020782b88c28c83">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::clear()</a>, <a class="el" href="class_linked_ref_map.html#a5fad70772de2ff561c5883f5a8919c5d">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::del()</a>, <a class="el" href="class_linked_ref_map.html#ad4eea714e29d412612981ac2a8bcab40">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::empty()</a>, <a class="el" href="class_linked_ref_map.html#a7d843d470df85d608d8d47b2a56c5e80">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::end()</a>, <a class="el" href="class_linked_ref_map.html#a89581f93afd0740dee45e136d1a54546">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::operator[]()</a>, <a class="el" href="class_linked_ref_map.html#a821db7bc14f1498938bd5314502f3655">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::prepend()</a>, <a class="el" href="class_linked_ref_map.html#ac971d2e3cc8e2651f5648b6946b25bd7">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::rbegin()</a>, <a class="el" href="class_linked_ref_map.html#a2a306a67c71e29179b309647309d6e96">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::rend()</a>, and <a class="el" href="class_linked_ref_map.html#a5fe0b41a59bcf683e2ade44911a3fe1d">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::size()</a>.</p>

</div>
</div>
<a id="aa825d33ecc2a6b96492886f163b7d47a" name="aa825d33ecc2a6b96492886f163b7d47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa825d33ecc2a6b96492886f163b7d47a">&#9670;&nbsp;</a></span>m_lookup</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Hash  = std::hash&lt;std::string&gt;, class KeyEqual  = std::equal_to&lt;std::string&gt;, class Map  = std::unordered_map&lt;std::string,T*,Hash,KeyEqual &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Map <a class="el" href="class_linked_ref_map.html">LinkedRefMap</a>&lt; T, Hash, KeyEqual, Map &gt;::m_lookup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html#l00384">384</a> of file <a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="class_linked_ref_map.html#a273fe87b60116a378346a858e11e4b6e">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::add()</a>, <a class="el" href="class_linked_ref_map.html#ad67fa2110f306614b020782b88c28c83">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::clear()</a>, <a class="el" href="class_linked_ref_map.html#a5fad70772de2ff561c5883f5a8919c5d">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::del()</a>, <a class="el" href="class_linked_ref_map.html#a9f6506fe8d15e7f43f61929560a3c377">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::find()</a>, and <a class="el" href="class_linked_ref_map.html#a821db7bc14f1498938bd5314502f3655">LinkedRefMap&lt; T, Hash, KeyEqual, Map &gt;::prepend()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>doxygen/build/doxygen/src/<a class="el" href="build_2doxygen_2src_2linkedmap_8h_source.html">linkedmap.h</a></li>
<li>doxygen/src/<a class="el" href="src_2linkedmap_8h_source.html">linkedmap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
